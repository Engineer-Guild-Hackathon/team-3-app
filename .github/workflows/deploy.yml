name: Deploy to Azure App Service (Container, Compose+Bake)

on:
  push:
    branches: [ "main" ]        # ← main に入ったら（= PR マージ含む）実行
  workflow_dispatch:             # ← 手動実行も残す

# 連打防止（新しい実行が来たら前のをキャンセル）
concurrency:
  group: prod-deploy
  cancel-in-progress: true

permissions:
  id-token: write   # ← OIDC 用（必須）
  contents: read

env:
  AZURE_RESOURCE_GROUP: WebApp                    # RG 名
  AZURE_WEBAPP_NAME: WebAppForHackathon           # Web App 名
  ACR_NAME: WebAppForHackathon                    # ACR 名
  ACR_LOGIN_SERVER: webappforhackathon-dme0eugjfte8atf2.azurecr.io  # ACR のログインサーバー名
  IMAGE_NAME: app-web                             # ACR のリポジトリ名
  IMAGE_TAG: ${{ github.sha }}                    # 一意タグ（latest も押す）
  CONTAINER_PORT: "3000"                          # あなたのアプリの待受ポート
  COMPOSE_FILE: docker-compose.prod.yml           # ルート直下の compose を使用
  BAKE_TARGET: web                                # compose 内の service 名
  BAKE_PLATFORM: linux/amd64                      # App Service は x64

jobs:
  db-migrate:
    name: DB migrate (Azure Postgres)
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    env:
      AZURE_RESOURCE_GROUP: WebApp
      PG_SERVER: webapp-for-hackathon                     # Flexible Server 名
      DB_NAME: team3app_prod
      FW_RULE_NAME: gha-runner-ip
      DATABASE_URL: ${{ secrets.DATABASE_URL }}           # ← 既に登録済み（sslmode=require 含む）
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      # 参考: OIDC で azure/login するのが推奨。

      - name: Get runner IPv4
        id: ip
        shell: bash
        run: |
          set -euo pipefail
          # IPv4 を強制。api.ipify.org はプレーンテキストでIPを返す
          IPV4=$(curl -4 -s https://api.ipify.org)
          if [[ -z "${IPV4}" ]]; then
            echo "Failed to get IPv4"; exit 1
          fi
          echo "ip=${IPV4}" >> "$GITHUB_OUTPUT"
      # ランナーのパブリックIPを取得（ipify使用）。

      - name: Allow firewall from runner IP
        run: |
          echo "Allowing ${IP} on Azure Postgres firewall..."
          az postgres flexible-server firewall-rule create \
            -g "${AZURE_RESOURCE_GROUP}" \
            -n "${PG_SERVER}" \
            --rule-name "${FW_RULE_NAME}" \
            --start-ip-address "${IP}" --end-ip-address "${IP}"
        env:
          IP: ${{ steps.ip.outputs.ipv4 }}
      # Postgres Flexible Server のFWルール追加。

      - name: Ensure pgcrypto is allow-listed (azure.extensions)
        shell: bash
        run: |
          set -euo pipefail
          current=$(az postgres flexible-server parameter show \
            -g "${AZURE_RESOURCE_GROUP}" -n "${PG_SERVER}" \
            --name azure.extensions --query value -o tsv || echo "")
          # 既存値に PGCRYPTO がなければ追加
          if [[ ",${current}," != *",PGCRYPTO,"* ]]; then
            if [[ -z "${current}" ]]; then
              new="PGCRYPTO"
            else
              new="${current},PGCRYPTO"
            fi
            echo "Enabling azure.extensions=${new}"
            az postgres flexible-server parameter set \
              -g "${AZURE_RESOURCE_GROUP}" -n "${PG_SERVER}" \
              --name azure.extensions --value "${new}"
          else
            echo "PGCRYPTO already allowed in azure.extensions=${current}"
          fi
      # 拡張の allow-list は azure.extensions パラメータで制御。

      - name: Install psql client
        run: sudo apt-get update && sudo apt-get install -y postgresql-client

      - name: Create extension(s) in database
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
        run: |
          # logging: "Create extensions if not exists"
          psql "${DATABASE_URL}" <<'SQL'
          CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA public;
          -- 必要なら UUID 用: CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA public;
          SQL
      # CREATE EXTENSION は DBごとに1回でOK。

      - name: Install Node & deps for migration
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - name: Migrate (Drizzle)
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          NEXT_TELEMETRY_DISABLED: 1
        run: |
          echo "Run DB migrations..."
          npm ci --no-audit --no-fund
          npm run -s db:migrate
      # Drizzle は __drizzle_migrations で冪等に管理。再実行も安全。

      - name: Remove firewall rule (cleanup)
        if: always()
        run: |
          echo "Cleaning firewall rule ${FW_RULE_NAME}..."
          az postgres flexible-server firewall-rule delete \
            -g "${AZURE_RESOURCE_GROUP}" -n "${PG_SERVER}" \
            --rule-name "${FW_RULE_NAME}" --yes
      # 実行後にFW閉じる（セキュリティ強化）。

  build-and-deploy:
    needs: db-migrate
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # --- Azure に OIDC ログイン（Secrets は ID 値のみ） ---
      # Secrets: AZURE_CLIENT_ID / AZURE_TENANT_ID / AZURE_SUBSCRIPTION_ID
      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      # 参考: OIDC での azure/login 推奨

      # --- ACR にログイン（push 用） ---
      - name: ACR Login via Azure CLI
        run: |
          echo "Logging in to ACR..."
          az acr login --name $ACR_NAME

      # --- Buildx + Bake（compose をそのままビルド＆push） ---
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Bake build and push from compose
        uses: docker/bake-action@v5
        with:
          files: ${{ env.COMPOSE_FILE }}
          targets: ${{ env.BAKE_TARGET }}     # compose の service 名
          push: true
          set: |
            ${{ env.BAKE_TARGET }}.platform=${{ env.BAKE_PLATFORM }}
            ${{ env.BAKE_TARGET }}.tags=${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
            ${{ env.BAKE_TARGET }}.tags=${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:latest
      # 参考: Compose→Bake で本番イメージを declarative にビルド

      # --- 念のためポート設定（初回/差分なくてもOK）---
      - name: Ensure WEBSITES_PORT
        run: |
          echo "Setting WEBSITES_PORT..."
          az webapp config appsettings set \
            -g $AZURE_RESOURCE_GROUP -n $AZURE_WEBAPP_NAME \
            --settings WEBSITES_PORT=${{ env.CONTAINER_PORT }}
      # 参考: カスタムコンテナは WEBSITES_PORT 必須

      # --- .env.example にあるキーを Secrets から注入（存在するもののみ設定） ---
      # GitHub → Settings → Secrets and variables → Actions に以下を登録してください:
      # - NEXTAUTH_SECRET, NEXTAUTH_URL
      # - GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET
      # - ALLOWED_EMAIL_DOMAIN, ALLOWED_EMAILS（任意）
      # - DATABASE_URL
      - name: Apply App Settings from Secrets
        shell: bash
        env:
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
          NEXTAUTH_URL: ${{ secrets.NEXTAUTH_URL }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          ALLOWED_EMAIL_DOMAIN: ${{ secrets.ALLOWED_EMAIL_DOMAIN }}
          ALLOWED_EMAILS: ${{ secrets.ALLOWED_EMAILS }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
        run: |
          set -euo pipefail
          declare -a SETTINGS
          add_setting() {
            local key="$1"; local val="$2"
            if [ -n "${val}" ]; then
              # 値が設定されているものだけを更新（空値で既存を消さない）
              SETTINGS+=("${key}=${val}")
            else
              echo "::notice title=Secret not set::Skipping ${key} (not provided)"
            fi
          }

          add_setting "NEXTAUTH_SECRET" "$NEXTAUTH_SECRET"
          add_setting "NEXTAUTH_URL" "$NEXTAUTH_URL"
          add_setting "GOOGLE_CLIENT_ID" "$GOOGLE_CLIENT_ID"
          add_setting "GOOGLE_CLIENT_SECRET" "$GOOGLE_CLIENT_SECRET"
          add_setting "ALLOWED_EMAIL_DOMAIN" "$ALLOWED_EMAIL_DOMAIN"
          add_setting "ALLOWED_EMAILS" "$ALLOWED_EMAILS"
          add_setting "DATABASE_URL" "$DATABASE_URL"

          if [ ${#SETTINGS[@]} -eq 0 ]; then
            echo "::warning title=No app settings applied::No matching Secrets were provided."
            exit 0
          fi

          echo "Applying $${#SETTINGS[@]} app settings..."
          az webapp config appsettings set \
            -g "$AZURE_RESOURCE_GROUP" -n "$AZURE_WEBAPP_NAME" \
            --settings "${SETTINGS[@]}"

      # --- Web App の使用イメージを更新（デプロイ） ---
      - name: Deploy to Web App (Container)
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.AZURE_WEBAPP_NAME }}
          images: ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
      # 参考: コンテナの反映は webapps-deploy の images 指定が公式推奨
